@app.route('/routes_query_two', methods=['GET', 'POST'])
# @identificate
def routes_query_two():
    # obtain datepicker input dates
    start = request.args['date_from'] or None
    stop = request.args['date_to'] or None
    # format selected datetimes for view
    start2 = start.split('T')[0]
    stop2 = stop.split('T')[0]

    activity_data = get_activity_paginated(session['token'], start, stop)[0]
    route_data = get_route_data(start, stop, 0, session['token'])

    costs = {'1mans': float(Costs.COSTS_ONE) / 60, '2mans': float(Costs.COSTS_TWO)/60}
    stop_rev = float(Costs.STOP_REV)
    rev_min = float(Costs.MIN_REV)
    stop_revs = json.loads(Costs.STOP_REVS)
    types = json.loads(Costs.TYPES)


    def delta(t1, t2):
        """Provides the timedelta between two datetime values in minutes"""
        try:
            d1 = dparser.parse(t1, fuzzy=True)
            d2 = dparser.parse(t2, fuzzy=True)
            factors = (60, 1, 1/60)
            duration = str((d2 - d1))
            duration_minutes = sum(i*j for i, j in zip(map(int, duration.split(':')), factors))
            return str(round(duration_minutes))
        except:
            return 'NA'

    def try_it(input_key):
        try:
            if input_key:
                return input_key
            else:
                return 'NA'
        except:
            return 'NA'

    def safeget(dct, *keys):
        for key in keys:
            try:
                dct = dct[key]
            except (KeyError, TypeError) as e:
                return 'NA'
        return dct

    def def_two_men(val_a, val_b, na_val):
        if val_a == na_val and val_b == na_val:
            return '2mans'
            # return True
        elif val_a != na_val and val_b != na_val:
            return '2mans'
            # return True
        elif val_b != na_val:
            return '2mans'
            # return True
        else:
            return '1mans'
            # return False

    def list_to_string(s):
        try:
            str1 = " "
            return (str1.join(s))
        except (KeyError, TypeError) as e:
            return 'NA'

    def split_it(it, split_char, split_index):
        try:
            if type(it) is str:
                return it.split(split_char)[split_index]
        except (KeyError, TypeError) as e:
            return 'NA'

    def sort_by_date(list_obj):
        try:
            list_obj.sort(key = lambda x:x['date'])
        except (KeyError, TypeError) as e:
            pass

    def get_tag(list_obj, tag):
        if list_obj:
            return tag in list_obj
        else:
            return False

    def rev_exp(driver, trailer, trailer_val, bool, costs_oneman, costs_twomen, stops, stop_rev, duration, rev_min, act_dur, loading_time, unloading_time):
        exp_costs = 0

        if driver == trailer_val and trailer == trailer_val:
            exp_costs = round(costs_twomen * float(duration), 2)
        elif trailer != trailer_val:
            exp_costs = round(costs_twomen * float(duration), 2)
        else:
            exp_costs = round(costs_oneman * float(duration), 2)


        rev = round(float(stops) * stop_rev + (float(act_dur) - float(loading_time) - float(unloading_time)) * rev_min, 2)

        try:
            margin = round(((rev - exp_costs) / rev), 2)
        except ZeroDivisionError:
            margin = 0

        return exp_costs, rev, margin

    def totals(list, object_to_sum):
        try:
            total = 0
            for i in list:
                total += float(i[object_to_sum])

            return round(total, 2)
        except TypeError:
            return 'NA'


    def ind_stop_rev(type_dict, stop_type, one_or_two, account, rev_per_min, stop_mins):

        try:
            ind_rev = 0
            if account != None:
                if one_or_two == '1mans':
                    ind_rev = type_dict.get(stop_type, 0) * 40 + stop_mins * rev_per_min
                elif one_or_two == '2mans':
                    ind_rev = type_dict.get(stop_type, 0) * 50 + stop_mins * rev_per_min
                else:
                    ind_rev = 0
            return ind_rev
        except:
            return 0






    # print(route_data)
    routes_list = []
    if route_data[1] == 200 and route_data[0]['items']:
        for i in route_data[0]['items']:
            routes_list.append({'id': safeget(i, 'id'), 'nr': safeget(i,'nr'), 'name': safeget(i, 'name'), 'nr_of_stops': safeget(i,'nr_of_stops'),
            'driver_full_name': safeget(i, 'driver', 'full_name'), 'trailer' :safeget(i, 'trailer', 'name'), 'car': safeget(i, 'car', 'name'), 'planned_driving_distance': try_it(str(round(int(i['planned_driving_distance'])/1000, 1))),
             'planned_activity_duration': safeget(i, 'planned_activity_duration'), 'billable_minutes': (float(safeget(i, 'planned_activity_duration')) - float(safeget(i, 'planned_start_duration')) - float(safeget(i, 'planned_end_duration'))),
             'planned_total_duration': safeget(i, 'planned_total_duration'), 'actual_duration': delta(safeget(i, 'executed_date_time_from'), safeget(i, 'executed_date_time_to')), 'date': split_it(safeget(i, 'planned_date_time_from'), ' ', 0), 'zones': list_to_string(safeget(i, 'zone_names')), 'two_man': def_two_men(safeget(i, 'driver', 'full_name'), safeget(i, 'trailer', 'name'), 'NA'),
             'planned_start_duration' : safeget(i, 'planned_start_duration'), 'planned_end_duration': safeget(i, 'planned_end_duration'), 'activity_ids': safeget(i, 'activity_ids'),
             'exp_costs': rev_exp(safeget(i, 'driver', 'full_name'), safeget(i, 'trailer', 'name'), 'NA', get_tag(safeget(i, 'tag_names'), '2mans'), costs['1mans'], costs['2mans'], safeget(i,'nr_of_stops'), stop_rev, safeget(i, 'planned_total_duration'),rev_min, safeget(i, 'planned_activity_duration'), safeget(i, 'planned_start_duration'), safeget(i, 'planned_end_duration'))[0],
             # 'exp_rev': rev_exp(safeget(i, 'driver', 'full_name'), safeget(i, 'trailer', 'name'), 'NA', get_tag(safeget(i, 'tag_names'), '2mans'), costs['1mans'], costs['2mans'], safeget(i,'nr_of_stops'), stop_rev, safeget(i, 'planned_total_duration'),rev_min, safeget(i, 'planned_activity_duration'), safeget(i, 'planned_start_duration'), safeget(i, 'planned_end_duration'))[1],
             'exp_margin': rev_exp(safeget(i, 'driver', 'full_name'), safeget(i, 'trailer', 'name'), 'NA', get_tag(safeget(i, 'tag_names'), '2mans'), costs['1mans'], costs['2mans'], safeget(i,'nr_of_stops'), stop_rev, safeget(i, 'planned_total_duration'),rev_min, safeget(i, 'planned_activity_duration'), safeget(i, 'planned_start_duration'), safeget(i, 'planned_end_duration'))[2] *100

              })



        sort_by_date(routes_list)
        for i in routes_list:
            route_rev = 0
            for j in i['activity_ids']:
                for k in activity_data:
                    if k['id'] == str(j):
                        temp = servicelevel(safeget(k, 'tags'), "tag_type_name", ['2mans'])
                        # print(routes_list[routes_list.index(i)]['activity_ids'][i['activity_ids'].index(j)])
                        routes_list[routes_list.index(i)]['activity_ids'][i['activity_ids'].index(j)] = {
                        'reference': safeget(k, 'reference'),
                        'party_name': safeget(k, 'assignment', 'party_name'),
                        'duration': safeget(k, 'duration'),
                        'servicelevel': servicelevel(safeget(k, 'tags'), "tag_type_name", ['Overalinhuis', 'Gebruiksklaar', 'Project', 'Ophalen+Verpakken (kwetsbaar)', 'Ophalen', 'Magazijnretour', 'Beganegrond', 'Magazijn Ophalen']),
                        'manpower': (lambda x : '2mans' if x == '2mans' else '1mans')(temp),
                        'stop_rev': ind_stop_rev(types, servicelevel(safeget(k, 'tags'), "tag_type_name", ['Overalinhuis', 'Gebruiksklaar', 'Project', 'Ophalen+Verpakken (kwetsbaar)', 'Ophalen', 'Magazijnretour', 'Beganegrond', 'Magazijn Ophalen']), (lambda x : '2mans' if x == '2mans' else '1mans')(temp), safeget(k, 'assignment', 'party_name'), 1, int(safeget(k, 'duration')))}
                        route_rev+=ind_stop_rev(types, servicelevel(safeget(k, 'tags'), "tag_type_name", ['Overalinhuis', 'Gebruiksklaar', 'Project', 'Ophalen+Verpakken (kwetsbaar)', 'Ophalen', 'Magazijnretour', 'Beganegrond', 'Magazijn Ophalen']), (lambda x : '2mans' if x == '2mans' else '1mans')(temp), safeget(k, 'assignment', 'party_name'), 1, int(safeget(k, 'duration')))
            routes_list[routes_list.index(i)]['exp_rev'] = route_rev



        exp_totals = {'sum_exp_costs': totals(routes_list, 'exp_costs'), 'sum_exp_rev': totals(routes_list, 'exp_rev')}
        exp_tot_mar = {'sum_exp_margin': round(((exp_totals['sum_exp_rev']-exp_totals['sum_exp_costs'])/exp_totals['sum_exp_rev'])*100, 3)}
        sum_stops = int(totals(routes_list, 'nr_of_stops'))

        return render_template('routes_query_two.html', title='Query results', date_from=start2, date_to=stop2, query=routes_list, totals=exp_totals, margin=exp_tot_mar, sum_stops=sum_stops)
